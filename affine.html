<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>invertransforms.affine API documentation</title>
<meta name="description" content="This module contains transform classes to apply affine transformations to images.
The transformation can be random or fixed.
Including specific â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>invertransforms.affine</code></h1>
</header>
<section id="section-intro">
<p>This module contains transform classes to apply affine transformations to images.
The transformation can be random or fixed.
Including specific transformations for rotations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains transform classes to apply affine transformations to images.
The transformation can be random or fixed.
Including specific transformations for rotations.

&#34;&#34;&#34;
import torch
from PIL import Image, PILLOW_VERSION
from torchvision import transforms
from torchvision.transforms.functional import _get_inverse_affine_matrix

from invertransforms import functional as F
from invertransforms.lib import InvertibleError, Invertible


class Affine(Invertible):
    &#34;&#34;&#34;
    Apply affine transformation on the image.

    Args:
        matrix (list of int): transformation matrix (from destination image to source)
         because we want to interpolate the (discrete) destination pixel from the local
         area around the (floating) source pixel.
    &#34;&#34;&#34;

    def __init__(self, matrix):
        self.matrix = matrix

    def inverse(self):
        matrix_inv = _invert_affine_matrix(self.matrix)
        return Affine(matrix_inv)

    def __call__(self, img):
        &#34;&#34;&#34;
        Args
            img (PIL Image): Image to be transformed.

        Returns:
            PIL Image: Affine transformed image.
        &#34;&#34;&#34;
        return _affine_with_matrix(img, self.matrix)

    def __repr__(self):
        return f&#39;{self.__class__.__name__}(matrix={self.matrix})&#39;


class RandomAffine(transforms.RandomAffine, Invertible):
    _matrix = None

    def __call__(self, img):
        &#34;&#34;&#34;
        Args
            img (PIL Image): Image to be transformed.

        Returns:
            PIL Image: Affine transformed image.
        &#34;&#34;&#34;
        params = self.get_params(self.degrees, self.translate, self.scale, self.shear, img.size)
        center = (img.size[0] * 0.5 + 0.5, img.size[1] * 0.5 + 0.5)
        self._matrix = _get_inverse_affine_matrix(center, *params)
        return F.affine(img, *params, resample=self.resample, fillcolor=self.fillcolor)

    def inverse(self):
        if not self._can_invert():
            raise InvertibleError(&#39;Cannot invert a random transformation before it is applied.&#39;)

        matrix_inv = _invert_affine_matrix(self._matrix)
        return Affine(matrix_inv)

    def _can_invert(self):
        return self._matrix is not None


def _affine_with_matrix(img, matrix, resample=0, fillcolor=None):
    kwargs = {&#34;fillcolor&#34;: fillcolor} if PILLOW_VERSION[0] &gt;= &#39;5&#39; else {}
    return img.transform(img.size, Image.AFFINE, matrix, resample, **kwargs)


def _invert_affine_matrix(matrix):
    if len(matrix) == 6:
        matrix += [0., 0., 1.]
    matrix = torch.tensor(matrix).reshape(3, 3)
    return matrix.inverse().reshape(-1).tolist()


class Rotation(Invertible):
    &#34;&#34;&#34;
    Rotate the image given an angle (in degrees).

    Args:
        angle (float or int): degrees of the angle
        resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):
            An optional resampling filter. See `filters`_ for more information.
            If omitted, or if the image has mode &#34;1&#34; or &#34;P&#34;, it is set to PIL.Image.NEAREST.
        expand (bool, optional): Optional expansion flag.
            If true, expands the output to make it large enough to hold the entire rotated image.
            If false or omitted, make the output image the same size as the input image.
            Note that the expand flag assumes rotation around the center and no translation.
        center (2-tuple, optional): Optional center of rotation.
            Origin is the upper left corner.
            Default is the center of the image.
    &#34;&#34;&#34;

    def __init__(self, angle, resample=False, expand=False, center=None):
        self.angle = angle
        self.resample = resample
        self.expand = expand
        self.center = center
        self._img_h = self._img_w = None

    def __call__(self, img):
        first_call = self._img_h is None or self._img_w is None
        if first_call:
            self._img_w, self._img_h = img.size
        img = F.rotate(img, -self.angle, self.resample, self.expand, self.center)
        if not first_call and self.expand:
            img = F.center_crop(img=img, output_size=(self._img_h, self._img_w))
        return img

    def inverse(self):
        if (self._img_h is None or self._img_w is None) and self.expand:
            raise InvertibleError(
                &#39;Cannot invert a transformation before it is applied&#39;
                &#39; (size of image before expanded rotation unknown).&#39;)  # note: the size could be computed
        rot = Rotation(
            angle=-self.angle,
            resample=self.resample,
            expand=self.expand,
            center=self.center,
        )
        rot._img_h, rot._img_w = self._img_h, self._img_w
        return rot

    def __repr__(self):
        format_string = self.__class__.__name__ + &#39;(angle={0}&#39;.format(self.angle)
        format_string += &#39;, resample={0}&#39;.format(self.resample)
        format_string += &#39;, expand={0}&#39;.format(self.expand)
        if self.center is not None:
            format_string += &#39;, center={0}&#39;.format(self.center)
        format_string += &#39;)&#39;
        return format_string


class RandomRotation(transforms.RandomRotation, Invertible):
    _angle = _img_h = _img_w = None

    def __call__(self, img):
        &#34;&#34;&#34;
        Args:
            img (PIL Image): Image to be rotated.

        Returns:
            PIL Image: Rotated image.
        &#34;&#34;&#34;
        self._angle = self.get_params(self.degrees)
        self._img_w, self._img_h = img.size
        return F.rotate(img, self._angle, self.resample, self.expand, self.center)

    def inverse(self):
        if not self._can_invert():
            raise InvertibleError(&#39;Cannot invert a random transformation before it is applied.&#39;)

        rot = Rotation(
            angle=-self._angle,
            resample=self.resample,
            expand=self.expand,
            center=self.center,
        )
        rot._img_h, rot._img_w = self._img_h, self._img_w
        return rot

    def _can_invert(self):
        return self._angle is not None and self._img_w is not None and self._img_h is not None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="invertransforms.affine.Affine"><code class="flex name class">
<span>class <span class="ident">Affine</span></span>
<span>(</span><span>matrix)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply affine transformation on the image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>transformation matrix (from destination image to source)</dd>
</dl>
<p>because we want to interpolate the (discrete) destination pixel from the local
area around the (floating) source pixel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Affine(Invertible):
    &#34;&#34;&#34;
    Apply affine transformation on the image.

    Args:
        matrix (list of int): transformation matrix (from destination image to source)
         because we want to interpolate the (discrete) destination pixel from the local
         area around the (floating) source pixel.
    &#34;&#34;&#34;

    def __init__(self, matrix):
        self.matrix = matrix

    def inverse(self):
        matrix_inv = _invert_affine_matrix(self.matrix)
        return Affine(matrix_inv)

    def __call__(self, img):
        &#34;&#34;&#34;
        Args
            img (PIL Image): Image to be transformed.

        Returns:
            PIL Image: Affine transformed image.
        &#34;&#34;&#34;
        return _affine_with_matrix(img, self.matrix)

    def __repr__(self):
        return f&#39;{self.__class__.__name__}(matrix={self.matrix})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></b></code>:
<ul class="hlist">
<li><code><a title="invertransforms.lib.Invertible.get_inverse" href="lib.html#invertransforms.lib.Invertible.get_inverse">get_inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.inverse" href="lib.html#invertransforms.lib.Invertible.inverse">inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.invert" href="lib.html#invertransforms.lib.Invertible.invert">invert</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.replay" href="lib.html#invertransforms.lib.Invertible.replay">replay</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.track" href="lib.html#invertransforms.lib.Invertible.track">track</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.tracked_inverses" href="lib.html#invertransforms.lib.Invertible.tracked_inverses">tracked_inverses</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="invertransforms.affine.RandomAffine"><code class="flex name class">
<span>class <span class="ident">RandomAffine</span></span>
<span>(</span><span>degrees, translate=None, scale=None, shear=None, resample=False, fillcolor=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Random affine transformation of the image keeping center invariant</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>degrees</code></strong> :&ensp;<code>sequence</code> or <code>float</code> or <code>int</code></dt>
<dd>Range of degrees to select from.
If degrees is a number instead of sequence like (min, max), the range of degrees
will be (-degrees, +degrees). Set to 0 to deactivate rotations.</dd>
<dt><strong><code>translate</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>tuple of maximum absolute fraction for horizontal
and vertical translations. For example translate=(a, b), then horizontal shift
is randomly sampled in the range -img_width * a &lt; dx &lt; img_width * a and vertical shift is
randomly sampled in the range -img_height * b &lt; dy &lt; img_height * b. Will not translate by default.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>scaling factor interval, e.g (a, b), then scale is
randomly sampled from the range a &lt;= scale &lt;= b. Will keep original scale by default.</dd>
<dt><strong><code>shear</code></strong> :&ensp;<code>sequence</code> or <code>float</code> or <code>int</code>, optional</dt>
<dd>Range of degrees to select from.
If shear is a number, a shear parallel to the x axis in the range (-shear, +shear)
will be apllied. Else if shear is a tuple or list of 2 values a shear parallel to the x axis in the
range (shear[0], shear[1]) will be applied. Else if shear is a tuple or list of 4 values,
a x-axis shear in (shear[0], shear[1]) and y-axis shear in (shear[2], shear[3]) will be applied.
Will not apply shear by default</dd>
<dt>resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):</dt>
<dt>An optional resampling filter. See <code>filters</code>_ for more information.</dt>
<dt>If omitted, or if the image has mode "1" or "P", it is set to PIL.Image.NEAREST.</dt>
<dt><strong><code>fillcolor</code></strong> :&ensp;<code>tuple</code> or <code>int</code></dt>
<dd>Optional fill color (Tuple for RGB Image And int for grayscale) for the area
outside the transform in the output image.(Pillow&gt;=5.0.0)</dd>
</dl>
<p>.. _filters: <a href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#filters">https://pillow.readthedocs.io/en/latest/handbook/concepts.html#filters</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomAffine(transforms.RandomAffine, Invertible):
    _matrix = None

    def __call__(self, img):
        &#34;&#34;&#34;
        Args
            img (PIL Image): Image to be transformed.

        Returns:
            PIL Image: Affine transformed image.
        &#34;&#34;&#34;
        params = self.get_params(self.degrees, self.translate, self.scale, self.shear, img.size)
        center = (img.size[0] * 0.5 + 0.5, img.size[1] * 0.5 + 0.5)
        self._matrix = _get_inverse_affine_matrix(center, *params)
        return F.affine(img, *params, resample=self.resample, fillcolor=self.fillcolor)

    def inverse(self):
        if not self._can_invert():
            raise InvertibleError(&#39;Cannot invert a random transformation before it is applied.&#39;)

        matrix_inv = _invert_affine_matrix(self._matrix)
        return Affine(matrix_inv)

    def _can_invert(self):
        return self._matrix is not None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torchvision.transforms.transforms.RandomAffine</li>
<li><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></b></code>:
<ul class="hlist">
<li><code><a title="invertransforms.lib.Invertible.get_inverse" href="lib.html#invertransforms.lib.Invertible.get_inverse">get_inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.inverse" href="lib.html#invertransforms.lib.Invertible.inverse">inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.invert" href="lib.html#invertransforms.lib.Invertible.invert">invert</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.replay" href="lib.html#invertransforms.lib.Invertible.replay">replay</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.track" href="lib.html#invertransforms.lib.Invertible.track">track</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.tracked_inverses" href="lib.html#invertransforms.lib.Invertible.tracked_inverses">tracked_inverses</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="invertransforms.affine.RandomRotation"><code class="flex name class">
<span>class <span class="ident">RandomRotation</span></span>
<span>(</span><span>degrees, resample=False, expand=False, center=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the image by angle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>degrees</code></strong> :&ensp;<code>sequence</code> or <code>float</code> or <code>int</code></dt>
<dd>Range of degrees to select from.
If degrees is a number instead of sequence like (min, max), the range of degrees
will be (-degrees, +degrees).</dd>
<dt>resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):</dt>
<dt>An optional resampling filter. See <code>filters</code>_ for more information.</dt>
<dt>If omitted, or if the image has mode "1" or "P", it is set to PIL.Image.NEAREST.</dt>
<dt><strong><code>expand</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Optional expansion flag.
If true, expands the output to make it large enough to hold the entire rotated image.
If false or omitted, make the output image the same size as the input image.
Note that the expand flag assumes rotation around the center and no translation.</dd>
</dl>
<p>center (2-tuple, optional): Optional center of rotation.
Origin is the upper left corner.
Default is the center of the image.
.. _filters: <a href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#filters">https://pillow.readthedocs.io/en/latest/handbook/concepts.html#filters</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomRotation(transforms.RandomRotation, Invertible):
    _angle = _img_h = _img_w = None

    def __call__(self, img):
        &#34;&#34;&#34;
        Args:
            img (PIL Image): Image to be rotated.

        Returns:
            PIL Image: Rotated image.
        &#34;&#34;&#34;
        self._angle = self.get_params(self.degrees)
        self._img_w, self._img_h = img.size
        return F.rotate(img, self._angle, self.resample, self.expand, self.center)

    def inverse(self):
        if not self._can_invert():
            raise InvertibleError(&#39;Cannot invert a random transformation before it is applied.&#39;)

        rot = Rotation(
            angle=-self._angle,
            resample=self.resample,
            expand=self.expand,
            center=self.center,
        )
        rot._img_h, rot._img_w = self._img_h, self._img_w
        return rot

    def _can_invert(self):
        return self._angle is not None and self._img_w is not None and self._img_h is not None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torchvision.transforms.transforms.RandomRotation</li>
<li><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></b></code>:
<ul class="hlist">
<li><code><a title="invertransforms.lib.Invertible.get_inverse" href="lib.html#invertransforms.lib.Invertible.get_inverse">get_inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.inverse" href="lib.html#invertransforms.lib.Invertible.inverse">inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.invert" href="lib.html#invertransforms.lib.Invertible.invert">invert</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.replay" href="lib.html#invertransforms.lib.Invertible.replay">replay</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.track" href="lib.html#invertransforms.lib.Invertible.track">track</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.tracked_inverses" href="lib.html#invertransforms.lib.Invertible.tracked_inverses">tracked_inverses</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="invertransforms.affine.Rotation"><code class="flex name class">
<span>class <span class="ident">Rotation</span></span>
<span>(</span><span>angle, resample=False, expand=False, center=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the image given an angle (in degrees).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>degrees of the angle</dd>
<dt>resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):</dt>
<dt>An optional resampling filter. See <code>filters</code>_ for more information.</dt>
<dt>If omitted, or if the image has mode "1" or "P", it is set to PIL.Image.NEAREST.</dt>
<dt><strong><code>expand</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Optional expansion flag.
If true, expands the output to make it large enough to hold the entire rotated image.
If false or omitted, make the output image the same size as the input image.
Note that the expand flag assumes rotation around the center and no translation.</dd>
</dl>
<p>center (2-tuple, optional): Optional center of rotation.
Origin is the upper left corner.
Default is the center of the image.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rotation(Invertible):
    &#34;&#34;&#34;
    Rotate the image given an angle (in degrees).

    Args:
        angle (float or int): degrees of the angle
        resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, optional):
            An optional resampling filter. See `filters`_ for more information.
            If omitted, or if the image has mode &#34;1&#34; or &#34;P&#34;, it is set to PIL.Image.NEAREST.
        expand (bool, optional): Optional expansion flag.
            If true, expands the output to make it large enough to hold the entire rotated image.
            If false or omitted, make the output image the same size as the input image.
            Note that the expand flag assumes rotation around the center and no translation.
        center (2-tuple, optional): Optional center of rotation.
            Origin is the upper left corner.
            Default is the center of the image.
    &#34;&#34;&#34;

    def __init__(self, angle, resample=False, expand=False, center=None):
        self.angle = angle
        self.resample = resample
        self.expand = expand
        self.center = center
        self._img_h = self._img_w = None

    def __call__(self, img):
        first_call = self._img_h is None or self._img_w is None
        if first_call:
            self._img_w, self._img_h = img.size
        img = F.rotate(img, -self.angle, self.resample, self.expand, self.center)
        if not first_call and self.expand:
            img = F.center_crop(img=img, output_size=(self._img_h, self._img_w))
        return img

    def inverse(self):
        if (self._img_h is None or self._img_w is None) and self.expand:
            raise InvertibleError(
                &#39;Cannot invert a transformation before it is applied&#39;
                &#39; (size of image before expanded rotation unknown).&#39;)  # note: the size could be computed
        rot = Rotation(
            angle=-self.angle,
            resample=self.resample,
            expand=self.expand,
            center=self.center,
        )
        rot._img_h, rot._img_w = self._img_h, self._img_w
        return rot

    def __repr__(self):
        format_string = self.__class__.__name__ + &#39;(angle={0}&#39;.format(self.angle)
        format_string += &#39;, resample={0}&#39;.format(self.resample)
        format_string += &#39;, expand={0}&#39;.format(self.expand)
        if self.center is not None:
            format_string += &#39;, center={0}&#39;.format(self.center)
        format_string += &#39;)&#39;
        return format_string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="invertransforms.lib.Invertible" href="lib.html#invertransforms.lib.Invertible">Invertible</a></b></code>:
<ul class="hlist">
<li><code><a title="invertransforms.lib.Invertible.get_inverse" href="lib.html#invertransforms.lib.Invertible.get_inverse">get_inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.inverse" href="lib.html#invertransforms.lib.Invertible.inverse">inverse</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.invert" href="lib.html#invertransforms.lib.Invertible.invert">invert</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.replay" href="lib.html#invertransforms.lib.Invertible.replay">replay</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.track" href="lib.html#invertransforms.lib.Invertible.track">track</a></code></li>
<li><code><a title="invertransforms.lib.Invertible.tracked_inverses" href="lib.html#invertransforms.lib.Invertible.tracked_inverses">tracked_inverses</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="invertransforms" href="index.html">invertransforms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="invertransforms.affine.Affine" href="#invertransforms.affine.Affine">Affine</a></code></h4>
</li>
<li>
<h4><code><a title="invertransforms.affine.RandomAffine" href="#invertransforms.affine.RandomAffine">RandomAffine</a></code></h4>
</li>
<li>
<h4><code><a title="invertransforms.affine.RandomRotation" href="#invertransforms.affine.RandomRotation">RandomRotation</a></code></h4>
</li>
<li>
<h4><code><a title="invertransforms.affine.Rotation" href="#invertransforms.affine.Rotation">Rotation</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>